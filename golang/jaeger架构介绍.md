> ​		工作中会遇到一种场景，用户反馈某个接口响应时间太久，需要优化，对于你来说，尤其是微服务盛行的当下，你可能需要通过排查各方日志才能知道这个请求从发起到返回的各个阶段都经历了那些服务、那些模块、各花费了多长时间。比如说我现在工作的业务场景里，前端发起请求，会先做用户的鉴权，此时会调用公司内部的系统鉴定这个用户名是否已经注册，然后会通过api网关，通过用户传参找到对应的服务名称，api网关再去数据库根据服务名称查询对应的url，将请求转发给后端真实的服务real server。后端服务再根据实际的业务需求做逻辑处理，这里面通常还会包含用户鉴权、调用下游服务、db存储等操作。现在你知道对于页面上看起来一个简单的按钮，实际后端做了多大一段不为人知的处理吧。那如果我们要做这个接口的响应耗时排查：我需要拉齐前端童鞋、api网关服务的童鞋、后端服务童鞋、后端服务被调用的童鞋A等BCD童鞋一起查看各方日志，你说一个还好，十个接口的话是不是得把你搞疯。这时候就出现了那句话：“当一件事情成为一件常态，那意味着我们可能需要一件工具来解放自己了，靠人终究是靠不住的”。因此分布式链路追踪系统就此诞生。
>
> ​		虽然分布式追踪系统种类繁多，但是核心步骤有三个：代码埋点，数据存储和查询展示。这次要介绍的Jaeger就属于追踪系统，上一节我已经带你初识了jaeger，你也可以自己搞个demo玩玩看，那我们这一节就来详细了解一下jaeger的架构吧！

## 一、背景

​		随着容器化及微服务技术的应用，服务的快速开发、部署、上线已经成为可能，构建维服务应用也越来越简单。但是随着单体运用拆分成微服务越来越普及的情况下，各服务之间的调用和依赖也变得更为复杂，这些服务可能由不同的团队开发、用不同的语言编写。对服务响应时间、排查、错误定位、日志分析等各方面都会产生众多不便。如何快速定位问题，如何厘清服务之间复杂的调用关系，如何查找服务性能的瓶颈所在，是我们亟待解决的问题。这就需要我们用到分布式链路追踪的技术，帮助我们解决上述问题。

## 二、Tracing在微服务中的作用	

​		和传统单体服务不同, 微服务通常部署在一个分布式的系统中, 并且一个请求可能会经过好几个微服务的处理, 这样的环境下错误和性能问题就会更容易发生, 所以观察(Observe)尤为重要。这就是Tracing的用武之地，它收集调用过程中的信息并可视化，让你知道在每一个服务调用过程的耗时等情况， 以便及早发现问题。

### 预期收益

1、一键查询上下游业务
2、链路耗时实时性反馈

### jaeger能够解决以下问题 

- 分布式跟踪信息传递
- 分布式事务监控
- 服务依赖性分析
- 展示跨进程调用链
- 定位问题
- 性能优化

## 三、Jaeger架构

### 1. 术语OpenTracing

为了解决不同的分布式追踪系统 API 不兼容的问题，诞生了 OpenTracing 规范。OpenTracing 是一个轻量级的标准化层，它位于应用程序/类库和追踪或日志分析程序之间。

一句话总结，OpenTracing是一套标准，它通过提供平台无关、厂商无关的API，使得开发人员能够方便的添加（或更换）追踪系统的实现（我们在测试使用中是基本上通过两行代码的更改就可以在Zipkin和Jaeger之间切换）。OpenTracing提供了用于运营支撑系统的和针对特定平台的辅助程序库。程序库的具体信息请参考详细的规范。OpenTracing 已进入 CNCF（云原生计算基金会，著名的Kubernetes、gRPC和Prometheus等均孵化于此），正在为全球的分布式追踪，提供统一的概念和数据标准。

### 2. 两个重要概念

在OpenTracing中，有两个主要概念：

- Trace(调用链): 一条Trace（调用链）可以被认为是一个由多个Span组成的有向无环图（DAG图）， Span与Span的关系被命名为References。

- Span(跨度)：跨度, 计量的最小单位, 每个跨度都有开始时间与截止时间。可以被理解为一次方法调用, 一个程序块的调用, 或者一次RPC/数据库访问. 只要是一个具有完整时间周期的程序访问，都可以被认为是一个Span。

  ![](/Users/zhouyang/Pictures/1454031-20190904111407539-468185481.png)

  ```
  		如图，A~E五个节点表示五个服务。用户发起一次请求RequestX到A，同时由于该请求依赖服务B与C，因此A分别发送RPC请求到B和C，B处理完请求后会直接返回到A，但是服务C还依赖服务D和E，因此还要发起两个RPC请求分别到D和E，D和E处理完毕后回到C，C才继续回复到A，最终A会回复用户ReplyX。对于这样一个请求，简单实用的分布式跟踪的实现，就是为服务器上每一次发送和接收动作来收集跟踪标识符和时间戳。
  ```

  ​		我们使用**Trace表示对一次请求完整调用链的跟踪，而将两个服务例如上面的服务A和服务B的请求/响应过程叫做一次Span**，trace是通过span来体现的， 通过一句话总结，我们可以将一次trace，看成是span的有向图，而这个有向图的边即为span。而分布式跟踪系统要做的，就是记录每次发送和接受动作的标识符和时间戳，将一次请求涉及到的所有服务串联起来，只有这样才能搞清楚一次请求的完整调用链。

### 3. jaeger组件介绍

- jaeger-client：客户端，实现了opentracing协议

- jaeger-agent：agent是一个网络守护进程，监听通过UDP发送过来的Span，它会将其批量发送给collector。按照设计，Agent要被部署到所有主机上，作为基础设施。Agent将collector和客户端之间的路由与发现机制抽象了出来。

- jaeger-collector【必须】：负责接收jaeger client或者jaeger agent上报上来的调用链数据，从Jaeger Agent接收Trace，并通过一个处理管道对其进行处理。目前的管道会校验Trace、建立索引、执行转换并最终进行存储。存储是一个可插入的组件，现在支持Cassandra和elasticsearch。

- jaeger-query【必须】：从存储中检索跟踪并托管UI来显示跟踪的服务

- jaeger-ingester：中文名称“摄食者”，可用从kafka读取数据然后写到jaeger的后端存储，比如Cassandra和Elasticsearch；

  ## jaeger架构图

  ![img](https://img2018.cnblogs.com/blog/1454031/201909/1454031-20190904143402449-1522468745.png)

  #### 1. Jaeger-client

  是Jaeger客户端代码库，便于不同语言的项目来介入到Jaeger中，当我们的应用程序装载上之后，client会负责收集并发送数据到Agent。

  - 实现了OpenTracing API接口
  - 当应用建立Span并发出请求到下游的服务时，它会附带跟踪信息(Trace ID, Span ID, baggage)。其他信息比如请求的名字，请求的参数，日志不会发给下游服务，而会被取样并异步的通过Jaeger-client发送到Jaeger-agent。
  - 因为创建跟踪信息的代价很小，跟踪功能是默认开启的。
  - 虽然跟踪功能是默认开启，但只有一部分的跟踪会被记录下来。默认比例是0.1%的取样

  这里再次放上这张图片结合上面的几点方便理解收集发送数据的操作：

  ![img](https://img2018.cnblogs.com/blog/1454031/201909/1454031-20190904143702090-1327549024.png)

  #### 2. Jaeger-agent:

  是Jaeger客户端代理，jaeger的agent，是一个监听在 UDP 端口上接收 span 数据的网络守护进程。 如同大多数分布式系统都拥有一个Agent一样，Jaeger的Agent有以下几类特点：

  - agent收集并汇聚这些span信息到collector；
  - agent的被设计成一个基础组件，旨在作为基础架构组件部署到所有宿主机；
  - agent将client library 和 collector 解耦，为 client library 屏蔽了路由和发现 collector 的细节；

  **总结如下：**

  - 与应用运行在同一个机器里
  - 负责接受从客户端通过UDP发来的Trace/Span信息
  - 批量上传到Jaeger收集器

  #### 3. Jaeger-collector

  collector，顾名思义，从agent收集traces信息，并通过处理管道处理他们，再写入后端存储（backends）。
  当前的collector工作主要是管理trace，建立索引，执行相关转换，并最终存储它们。
  Collector中运行着sampling逻辑，根据我们设定的sampling方式对数据进行收集和处理。

  **总结如下：**

  - 接受从agent发来的Trace/Span信息
  - 进行信息校验，索引和存储到后台的数据库

  #### 4. DB

  即数据存储。Jaeger的存储是一个可插拔的组件，目前支持Cassandra，Elasticsearch和Kafka（当然也支持纯内存方式，但是不适用于生产环境）

  #### 5. Query & UI

  数据查询与前端界面展示。Query查询是一种从存储中检索trace，并提供UI以显示它们的服务。上图中就展示了一次Trace的数据流向，作为一次系统作用的数据传播/执行图，即可以在Jaeger UI上展示出来。

## 三、关于采样率

分布式追踪系统本身也会造成一定的性能低损耗，如果完整记录每次请求，对于生产环境可能会有极大的性能损耗，一般需要进行采样设置。

**当前支持四种采样率设置：**

- 固定采样（sampler.type=const）sampler.param=1 全采样， sampler.param=0 不采样；
- 按百分比采样（sampler.type=probabilistic）sampler.param=0.1 则随机采十分之一的样本；
- 采样速度限制（sampler.type=ratelimiting）sampler.param=2.0 每秒采样两个traces；
- 动态获取采样率 (sampler.type=remote) 这个是默认配置，可以通过配置从 Agent 中获取采样率的动态设置。



## 参考文献

[jager](https://www.cnblogs.com/sunlong88/p/14324911.html)

[分布式链路追踪系统：Jaeger在golang中的应用](https://studygolang.com/articles/28685?fr=sidebar)

[开源分布式追踪系统 — Jaeger介绍](https://www.cnblogs.com/ChangAn223/p/11458226.html)

[官方文档](https://opentracing.io/docs/overview/what-is-tracing/)

[全链路监控Jaeger搭建实战](https://www.jianshu.com/p/ffc597bb4ce8)



